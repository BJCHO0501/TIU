### 원시 타입
- Boolean, String, Number, null, undefined
- 원시 타입 데이터는 변수에 할당될 때 메모리에 고정된 크기로 스택 영역에 저장되고 해당 변수는 값을 보관한다.
- 값이 절때 변하지 않는 불변성을 갖고 있어 재할당 시 기존 값이 변하는 것이 아닌 새로운 메모리에 재할당한 값이 저장되고 변수가 가리키는 메모리가 달라진다.
  ![](images/Pasted%20image%2020250110160947.png)

### 참조 타입
- 객체(Object), 배열(Array), 함수(function) (원시 타입을 제외한 나머지)
- 참조타입은 변수에 할당될 때 값이 직접 저장되는 것이 아니라 변수의 값이 저장된 Heap 메모리 주소의 값을 저장한다.
- 크기가 동적으로 변하기 때문에 Heap에서 관리함
  ![](images/Pasted%20image%2020250110161254.png)

### 깊은 복사
- 실제 값을 복사하는 것
- 값을 복사하기 때문에 주소가 달라 복사한 값을 변경하더라도 원본 값에 영향을 주지 않는다.
``` js
const a = 'a';
let b = 'b';

b = 'c';

// 기존 값에 영향을 끼치지 않음
console.log(a, b); // 'a c';
```

### 깊은 비교
- 깊은 복사와 같이 참초 타입의 경우에도 값으로 비교하는 방법이다.
- depth가 깊지 않은 경우 JSON.stringify()를 사용,
- depth가 깊은 경우 lodash라이브러리의 isEqual()을 사용한다.

### 얕은 복사
- 주소만 복사하여 가져오는 것
- 최소한의 주소만 복사함으로 깊은 복사에 비해 빠르다.
``` js
const a = {
  one: 1,
  two: 2,
};

let b = a;
b.one = 3;

// 기존 값에 영향을 끼침
console.log(a); // { one: 3, two: 2 } 출력
console.log(b); // { one: 3, two: 2 } 출력
```
- b는 a를 얕게 복사하여 주소만 복사해 오기 때문에, b를 변경하였을 때 a에도 영향을 준다.

### 얕은 비교
- 원시 타입의 경우, 값을 비교한다.
- 참조 타입의 경우 값 또는 속성을 비교하지 않고, 참도되는 위치(주소)를 비교한다.
- 따라서, 만약 두 Object의 모든 속성 값이 일치하더라도 주소가 다르다면 다르다고 비교하기 된다.
```js
let str1 = "same";
let str2 = "same";
console.log(str1 === str2);// true

let arr1 = [1, 2, 3];
let arr2 = [1, 2, 3];
console.log(arr1 === arr2);// false, 참조되는 위치(주소)가 다름
```
